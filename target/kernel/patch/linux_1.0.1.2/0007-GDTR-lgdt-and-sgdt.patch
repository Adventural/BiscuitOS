From 0a63f201473bce36f091ba410915b28c8304df85 Mon Sep 17 00:00:00 2001
From: BuddyZhang1 <buddy.zhang@aliyun.com>
Date: Tue, 7 Aug 2018 18:51:59 +0800
Subject: [PATCH 07/27] GDTR: lgdt and sgdt

---
 tools/demo/mmu/storage/register/CS/Kconfig     |  26 +++++
 tools/demo/mmu/storage/register/CS/Makefile    |   1 +
 tools/demo/mmu/storage/register/CS/cs.c        | 150 +++++++++++++++++++++++++
 tools/demo/mmu/storage/register/GDTR/Kconfig   |  26 +++++
 tools/demo/mmu/storage/register/GDTR/Makefile  |   1 +
 tools/demo/mmu/storage/register/GDTR/README.md |  28 +++++
 tools/demo/mmu/storage/register/GDTR/gdtr.c    | 113 +++++++++++++++++++
 tools/demo/mmu/storage/register/Kconfig        |   5 +-
 tools/demo/mmu/storage/register/Makefile       |   3 +-
 tools/demo/mmu/storage/register/cs/Kconfig     |  26 -----
 tools/demo/mmu/storage/register/cs/Makefile    |   1 -
 tools/demo/mmu/storage/register/cs/cs.c        | 150 -------------------------
 tools/demo/mmu/storage/stack/stack.c           |  43 ++++++-
 13 files changed, 390 insertions(+), 183 deletions(-)
 create mode 100644 tools/demo/mmu/storage/register/CS/Kconfig
 create mode 100644 tools/demo/mmu/storage/register/CS/Makefile
 create mode 100644 tools/demo/mmu/storage/register/CS/cs.c
 create mode 100644 tools/demo/mmu/storage/register/GDTR/Kconfig
 create mode 100644 tools/demo/mmu/storage/register/GDTR/Makefile
 create mode 100644 tools/demo/mmu/storage/register/GDTR/README.md
 create mode 100644 tools/demo/mmu/storage/register/GDTR/gdtr.c
 delete mode 100644 tools/demo/mmu/storage/register/cs/Kconfig
 delete mode 100644 tools/demo/mmu/storage/register/cs/Makefile
 delete mode 100644 tools/demo/mmu/storage/register/cs/cs.c

diff --git a/tools/demo/mmu/storage/register/CS/Kconfig b/tools/demo/mmu/storage/register/CS/Kconfig
new file mode 100644
index 0000000..70a5fe3
--- /dev/null
+++ b/tools/demo/mmu/storage/register/CS/Kconfig
@@ -0,0 +1,26 @@
+#
+# CS: Code selector Register
+#
+
+menu "CS:       Code selector Register"
+
+config DEBUG_REGISTER_CS
+	bool "CS: Code selector Register"
+	help
+	  Debug Code selector Register.
+
+if DEBUG_REGISTER_CS
+
+config DEBUG_SEGMENT_SELECTOR_CS
+	bool "Parse CS segment selector."
+	help
+	  Parse CS Segment selector.
+
+config DEBUG_SEGMENT_DESCRIPTOR_CS
+	bool "Parse segment descriptor for CS."
+	help
+	  Parse Segment descriptor for CS.
+
+endif
+
+endmenu
diff --git a/tools/demo/mmu/storage/register/CS/Makefile b/tools/demo/mmu/storage/register/CS/Makefile
new file mode 100644
index 0000000..eb3c3f6
--- /dev/null
+++ b/tools/demo/mmu/storage/register/CS/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_DEBUG_REGISTER_CS)     += cs.o
diff --git a/tools/demo/mmu/storage/register/CS/cs.c b/tools/demo/mmu/storage/register/CS/cs.c
new file mode 100644
index 0000000..0060da9
--- /dev/null
+++ b/tools/demo/mmu/storage/register/CS/cs.c
@@ -0,0 +1,150 @@
+/*
+ * CS: Code selector Register
+ *
+ * (C) 2018.06.06 BiscuitOS <buddy.zhang@aliyun.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+
+#include <demo/debug.h>
+
+static inline unsigned long get_cs(void)
+{
+    unsigned long _v;
+
+    __asm__ ("mov %%cs, %w0" : "=r" (_v) : "0" (0));
+    return _v;
+}
+
+#ifdef CONFIG_DEBUG_SEGMENT_SELECTOR_CS
+/*
+ * Parse CS segment selector
+ *   A segment selector is a 16-bit identifier for a semgent(see Figure).
+ *   It doesn't point directly to the segment, but instead points to the
+ *   segment descriptor that defines the segment. A segment selector 
+ *   contains the following items:
+ *
+ *   15------------------------------3----2--1--0
+ *   |  Index                        | TI | RPL |
+ *   --------------------------------------------     
+ */
+static void parse_segment_selector_cs(void)
+{
+    unsigned short cs;
+
+    /* Obtain CS */
+    cs = get_cs();
+
+    /*
+     * The first entry of the GDT is not used by the processor. A CS segment
+     * selector that points to this entry of the GDT (that is, a segment
+     * selector with an index of 0 and the TI flag set to 0) is used as
+     * a "Null segment selector". The processor doesn't generate an 
+     * exception when a segment register (other than the CS or SS registers)
+     * is loaded with a null selector. It does, however, generate an 
+     * exception when a segment register holding a null selector is used
+     * to access memory. A null selector can be used to initialize unused
+     * segment registers. Loading the CS or SS register with a null segment
+     * selector causes a general-protection exception (#GP) to be generated.
+     */
+    if (((cs >> 0x02) & 0x01) & ((cs >> 0x03) == 0x00))
+        printk("NULL segment selecor on GDT/LDT.\n");
+
+    /*
+     * Index
+     *   (Bit 3 through 15) - Selects one of 8192 descriptors in the GDT or
+     *   LDT. The processor multiplies the index value by 8 (the number of
+     *   bytes in a segment descriptor) and adds the result to the base
+     *   address of the GDT or LDT (from the GDTR or LDTR register).
+     */
+    printk("The index of Selector: %#x\n", cs >> 0x3);
+
+    /*
+     * TI (table indicator) flag
+     *   (Bit 2) - Specifies the descriptor table to use. Clearing this flag
+     *   selects the GDT. Setting this flag selects the current LDT.
+     */
+    if ((cs >> 2) % 0x1)
+        printk("Point Segment on LDT\n");
+    else
+        printk("Point Segment on GDT\n");
+
+    /*
+     * Request Privilege Level (RPL)
+     *   (Bit 0 and 1) - Specifies the privilege level of the selector. The
+     *   The privilege level can range from 0 to 3, with 0 being the most
+     *   privileged level. For a descriptor of the relationship of the RPL
+     *   to the CPL of the executing program (or task) and the descriptor
+     *   privilege level (DPL) of the descriptor the segment selector points
+     *   to.
+     */
+    printk("RPL: %#x\n", cs & 0x3);
+
+    /*
+     * Segment selectors are visible to application program as part of a
+     * pointer variable, but the values of selectors are usually assigned
+     * or modified by link editors or linking loaders, not application 
+     * programs.
+     */
+}
+#endif
+
+#ifdef CONFIG_DEBUG_SEGMENT_DESCRIPTOR_CS
+/*
+ * parse_segment_descriptor_cs()
+ *   Parse a segment descriptor for CS. The CS points a speical descriptor
+ *   where locate in LDT or GDT. The segment descriptor describe
+ *   base address, limit, flags and permission for current Code segment.
+ *   According to TI bit on CS, we can obtain a special segment descriptor.
+ *   If 'TI' is cleared, the CS points to GDT, and if it is set, the CS
+ *   points to LDT.
+ * 
+ *   0--------------+----+-----15
+ *   |     Index    | TI |      |
+ *   +--------------+----+------+ 
+ *          |
+ *          |
+ *          |
+ *          |
+ *          |            (TI = 1)
+ *          o----o------------------------o
+ *               |                        |
+ *               |                        V
+ *               |            0-----------+--------------------+-----
+ *               |            |           |                    |
+ *               |            | LDT ..... | Segment descriptor |
+ *               |            |           |                    |
+ *               | (TI = 0)   +-----------+--------------------+-----
+ *               |
+ *               V
+ *   0-----------+--------------------+----
+ *   |           |                    |
+ *   | GDT ....  | Segment descriptor |...
+ *   |           |                    |
+ *   +-----------+--------------------+----
+ */
+static void parse_segment_descriptor_cs(void)
+{
+    unsigned short cs;
+
+    /* Obtain CS segment selector */
+    cs = get_cs();
+    printk("CS %#x\n", cs);
+}
+#endif
+
+static int debug_cs(void)
+{
+#ifdef CONFIG_DEBUG_SEGMENT_SELECTOR_CS
+    parse_segment_selector_cs();
+#endif
+
+#ifdef CONFIG_DEBUG_SEGMENT_DESCRIPTOR_CS
+    parse_segment_descriptor_cs();
+#endif
+    return 0;
+}
+late_debugcall(debug_cs);
diff --git a/tools/demo/mmu/storage/register/GDTR/Kconfig b/tools/demo/mmu/storage/register/GDTR/Kconfig
new file mode 100644
index 0000000..7acff2a
--- /dev/null
+++ b/tools/demo/mmu/storage/register/GDTR/Kconfig
@@ -0,0 +1,26 @@
+#
+# GDTR: Global Descriptor Table Register
+#
+
+menu "GDTR:     Global Descriptor Table Register"
+
+config DEBUG_REGISTER_GDTR
+	bool "GDTR: Global Descriptor table regsiter"
+	help
+	  Debug GDTR Register.
+
+if DEBUG_REGISTER_GDTR
+
+config DEBUG_GDTR_SGDT
+	bool "SGDT: Store Global Descriptor Table Register"
+	help
+	  Store GDTR into linear address.
+
+config DEBUG_GDTR_LGDT
+	bool "LGDT: Load  Global Descriptor Table Register"
+	help
+	  Load linear address into GDTR.
+
+endif
+
+endmenu
diff --git a/tools/demo/mmu/storage/register/GDTR/Makefile b/tools/demo/mmu/storage/register/GDTR/Makefile
new file mode 100644
index 0000000..f17d069
--- /dev/null
+++ b/tools/demo/mmu/storage/register/GDTR/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_DEBUG_REGISTER_GDTR)     += gdtr.o
diff --git a/tools/demo/mmu/storage/register/GDTR/README.md b/tools/demo/mmu/storage/register/GDTR/README.md
new file mode 100644
index 0000000..3188e24
--- /dev/null
+++ b/tools/demo/mmu/storage/register/GDTR/README.md
@@ -0,0 +1,28 @@
+Global Descriptor Table Register (GDTR)
+---------------------------------------------------------------------
+
+```
+ GDTR
+
+ 47                             16 15                      0
+ +--------------------------------+------------------------+
+ |                                |                        |
+ |   32-Bit Linear Base Address   |   16-Bit Table Limit   |
+ |                                |                        |
+ +--------------------------------+------------------------+
+
+```
+
+The `GDTR` register holds the base address and the 16-bit table limit for
+the `GDT`. The base address specifies the linear address of byte 0 of the
+GDT. The table limit specifies the number of bytes in the table.
+
+The `LGDT` and `SGDT` instructions load and store the GDTR regsiter,
+respectively. On power up or reset of the processor, the base address is
+set to the default value of 0 and the limit is set to 0xFFFFH. A new 
+base address must be loaded into the `GDTR` as part of the processor
+initlization process for protected-mode operation.
+
+## link
+
+  [Intel Architectures Software Developer's Manual: Combined Volumes: 3 -- Chapter 2 System architecture overview: 2.4 Memory-Management register](https://software.intel.com/en-us/articles/intel-sdm)
diff --git a/tools/demo/mmu/storage/register/GDTR/gdtr.c b/tools/demo/mmu/storage/register/GDTR/gdtr.c
new file mode 100644
index 0000000..748047e
--- /dev/null
+++ b/tools/demo/mmu/storage/register/GDTR/gdtr.c
@@ -0,0 +1,113 @@
+/*
+ * GDTR: Global Descriptor Table Register
+ *
+ * (C) 2018.08.07 BiscuitOS <buddy.zhang@aliyun.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/sched.h>
+
+#include <demo/debug.h>
+
+struct gdtr_desc 
+{
+    unsigned short limit;
+    unsigned long linear;
+};
+
+/*
+ * SGDT -- Store Global Descriptor Table Register
+ *  
+ *   SGDT m
+ *
+ *   Stores the content of the global descriptor table register (GDTR) in
+ *   the destination operand. The destination operand specifies a memory
+ *   location.
+ *
+ *   In legacy or compatibility mode, the destination operand is a 6-byte
+ *   memory location. If the operand-size attribute is 16 or 32 bits, the
+ *   16-bit limit field of the register is store in the low 2 bytes of the
+ *   memory location and the 32-bit base address is stored in the high
+ *   4 bytes.
+ *
+ *   SGDT is useful only by operating-system software. However, it can be
+ *   used in application program without causing an exception to be 
+ *   generated if CR4.UMIP = 0.
+ *
+ *   Operation
+ *   IF instruction is SGDT
+ *       IF OperandSize = 16 or OperandSize = 32 (Legacy or Compatibility Mode)
+ *           DEST[0:15]  <----- GDTR(limit)
+ *           DEST[16:47] <----- GDTR(Base) (Full 32-bit base address stored)
+ *       ELSE (64-bit Mode)
+ *           DEST[0:15]  <----- GDTR(limit)
+ *           DEST[16:79] <----- GDTR(Base) (Full 64-bit base address stored)
+ *       FI
+ *   FI
+ *
+ */
+/* Operand of SGDT */
+static __unused int gdtr_sdtr(void)
+{
+    struct gdtr_desc gdtr;
+
+    __asm__ ("sgdt %0" : "=m" (gdtr));
+
+    if (gdtr.limit != ((8 + 2 * NR_TASKS) * 8 - 1))
+        panic("SGDT: invalid gdtr limit");
+    return 0;
+}
+
+/*
+ * LGDT - Load Global Descriptor Table Register
+ *
+ *   LGDT m32
+ *
+ *   Loads the values in the source operand into the global descriptor table
+ *   register (GDTR). The source operand specifies a 6 byte memory location
+ *   that contains the base address (a linear address) and the limit (size
+ *   of table in bytes) of the global descriptor table (GDT). If operand-size
+ *   attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data
+ *   operand) and a 32-bit base address (upper 4 bytes of the data operand)
+ *   are loaded into the register.
+ *
+ *   The LGDT instruction are used only in operating-system software. They
+ *   are not used in application programs. They are the only instructions
+ *   that directly load a linear address (that is, not a segment-relative
+ *   address) and a limit in protected mode.
+ *
+ *   IF Instruction is LGDT
+ *       IF OperandSize = 32
+ *           THEN
+ *               GDTR(limit)   <--- SRC[0:15]
+ *               GDTR(Base)    <--- SRC[16:47]
+ *           FI
+ *       FI
+ *   FI
+ */
+static __unused int gdtr_lgdt(void)
+{
+    struct gdtr_desc gdtr;
+
+    __asm__ ("sgdt %0" : "=m" (gdtr));
+
+    __asm__ ("lgdt %0" :: "m" (gdtr));
+
+    return 0;
+}
+
+static int debug_gdtr(void)
+{
+#ifdef CONFIG_DEBUG_GDTR_SGDT
+    gdtr_sdtr();
+#endif
+
+#ifdef CONFIG_DEBUG_GDTR_LGDT
+    gdtr_lgdt();
+#endif
+    return 0;
+}
+late_debugcall(debug_gdtr);
diff --git a/tools/demo/mmu/storage/register/Kconfig b/tools/demo/mmu/storage/register/Kconfig
index 8998f6c..3123507 100644
--- a/tools/demo/mmu/storage/register/Kconfig
+++ b/tools/demo/mmu/storage/register/Kconfig
@@ -10,8 +10,11 @@ config DEBUG_REGISTER
 
 if DEBUG_REGISTER
 
+# GDTR Register
+source "tools/demo/mmu/storage/register/GDTR/Kconfig"
+
 # CS Register
-source "tools/demo/mmu/storage/register/cs/Kconfig"
+source "tools/demo/mmu/storage/register/CS/Kconfig"
 
 endif
 
diff --git a/tools/demo/mmu/storage/register/Makefile b/tools/demo/mmu/storage/register/Makefile
index 6223384..f41a64c 100644
--- a/tools/demo/mmu/storage/register/Makefile
+++ b/tools/demo/mmu/storage/register/Makefile
@@ -1 +1,2 @@
-obj-$(CONFIG_DEBUG_REGISTER_CS)    += cs/
+obj-$(CONFIG_DEBUG_REGISTER_GDTR)       += GDTR/
+obj-$(CONFIG_DEBUG_REGISTER_CS)         += CS/
diff --git a/tools/demo/mmu/storage/register/cs/Kconfig b/tools/demo/mmu/storage/register/cs/Kconfig
deleted file mode 100644
index ba9f380..0000000
--- a/tools/demo/mmu/storage/register/cs/Kconfig
+++ /dev/null
@@ -1,26 +0,0 @@
-#
-# CS: Code selector Register
-#
-
-menu "CS: Code selector Register"
-
-config DEBUG_REGISTER_CS
-	bool "CS: Code selector Register"
-	help
-	  Debug Code selector Register.
-
-if DEBUG_REGISTER_CS
-
-config DEBUG_SEGMENT_SELECTOR_CS
-	bool "Parse CS segment selector."
-	help
-	  Parse CS Segment selector.
-
-config DEBUG_SEGMENT_DESCRIPTOR_CS
-	bool "Parse segment descriptor for CS."
-	help
-	  Parse Segment descriptor for CS.
-
-endif
-
-endmenu
diff --git a/tools/demo/mmu/storage/register/cs/Makefile b/tools/demo/mmu/storage/register/cs/Makefile
deleted file mode 100644
index eb3c3f6..0000000
--- a/tools/demo/mmu/storage/register/cs/Makefile
+++ /dev/null
@@ -1 +0,0 @@
-obj-$(CONFIG_DEBUG_REGISTER_CS)     += cs.o
diff --git a/tools/demo/mmu/storage/register/cs/cs.c b/tools/demo/mmu/storage/register/cs/cs.c
deleted file mode 100644
index 0060da9..0000000
--- a/tools/demo/mmu/storage/register/cs/cs.c
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * CS: Code selector Register
- *
- * (C) 2018.06.06 BiscuitOS <buddy.zhang@aliyun.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include <linux/kernel.h>
-
-#include <demo/debug.h>
-
-static inline unsigned long get_cs(void)
-{
-    unsigned long _v;
-
-    __asm__ ("mov %%cs, %w0" : "=r" (_v) : "0" (0));
-    return _v;
-}
-
-#ifdef CONFIG_DEBUG_SEGMENT_SELECTOR_CS
-/*
- * Parse CS segment selector
- *   A segment selector is a 16-bit identifier for a semgent(see Figure).
- *   It doesn't point directly to the segment, but instead points to the
- *   segment descriptor that defines the segment. A segment selector 
- *   contains the following items:
- *
- *   15------------------------------3----2--1--0
- *   |  Index                        | TI | RPL |
- *   --------------------------------------------     
- */
-static void parse_segment_selector_cs(void)
-{
-    unsigned short cs;
-
-    /* Obtain CS */
-    cs = get_cs();
-
-    /*
-     * The first entry of the GDT is not used by the processor. A CS segment
-     * selector that points to this entry of the GDT (that is, a segment
-     * selector with an index of 0 and the TI flag set to 0) is used as
-     * a "Null segment selector". The processor doesn't generate an 
-     * exception when a segment register (other than the CS or SS registers)
-     * is loaded with a null selector. It does, however, generate an 
-     * exception when a segment register holding a null selector is used
-     * to access memory. A null selector can be used to initialize unused
-     * segment registers. Loading the CS or SS register with a null segment
-     * selector causes a general-protection exception (#GP) to be generated.
-     */
-    if (((cs >> 0x02) & 0x01) & ((cs >> 0x03) == 0x00))
-        printk("NULL segment selecor on GDT/LDT.\n");
-
-    /*
-     * Index
-     *   (Bit 3 through 15) - Selects one of 8192 descriptors in the GDT or
-     *   LDT. The processor multiplies the index value by 8 (the number of
-     *   bytes in a segment descriptor) and adds the result to the base
-     *   address of the GDT or LDT (from the GDTR or LDTR register).
-     */
-    printk("The index of Selector: %#x\n", cs >> 0x3);
-
-    /*
-     * TI (table indicator) flag
-     *   (Bit 2) - Specifies the descriptor table to use. Clearing this flag
-     *   selects the GDT. Setting this flag selects the current LDT.
-     */
-    if ((cs >> 2) % 0x1)
-        printk("Point Segment on LDT\n");
-    else
-        printk("Point Segment on GDT\n");
-
-    /*
-     * Request Privilege Level (RPL)
-     *   (Bit 0 and 1) - Specifies the privilege level of the selector. The
-     *   The privilege level can range from 0 to 3, with 0 being the most
-     *   privileged level. For a descriptor of the relationship of the RPL
-     *   to the CPL of the executing program (or task) and the descriptor
-     *   privilege level (DPL) of the descriptor the segment selector points
-     *   to.
-     */
-    printk("RPL: %#x\n", cs & 0x3);
-
-    /*
-     * Segment selectors are visible to application program as part of a
-     * pointer variable, but the values of selectors are usually assigned
-     * or modified by link editors or linking loaders, not application 
-     * programs.
-     */
-}
-#endif
-
-#ifdef CONFIG_DEBUG_SEGMENT_DESCRIPTOR_CS
-/*
- * parse_segment_descriptor_cs()
- *   Parse a segment descriptor for CS. The CS points a speical descriptor
- *   where locate in LDT or GDT. The segment descriptor describe
- *   base address, limit, flags and permission for current Code segment.
- *   According to TI bit on CS, we can obtain a special segment descriptor.
- *   If 'TI' is cleared, the CS points to GDT, and if it is set, the CS
- *   points to LDT.
- * 
- *   0--------------+----+-----15
- *   |     Index    | TI |      |
- *   +--------------+----+------+ 
- *          |
- *          |
- *          |
- *          |
- *          |            (TI = 1)
- *          o----o------------------------o
- *               |                        |
- *               |                        V
- *               |            0-----------+--------------------+-----
- *               |            |           |                    |
- *               |            | LDT ..... | Segment descriptor |
- *               |            |           |                    |
- *               | (TI = 0)   +-----------+--------------------+-----
- *               |
- *               V
- *   0-----------+--------------------+----
- *   |           |                    |
- *   | GDT ....  | Segment descriptor |...
- *   |           |                    |
- *   +-----------+--------------------+----
- */
-static void parse_segment_descriptor_cs(void)
-{
-    unsigned short cs;
-
-    /* Obtain CS segment selector */
-    cs = get_cs();
-    printk("CS %#x\n", cs);
-}
-#endif
-
-static int debug_cs(void)
-{
-#ifdef CONFIG_DEBUG_SEGMENT_SELECTOR_CS
-    parse_segment_selector_cs();
-#endif
-
-#ifdef CONFIG_DEBUG_SEGMENT_DESCRIPTOR_CS
-    parse_segment_descriptor_cs();
-#endif
-    return 0;
-}
-late_debugcall(debug_cs);
diff --git a/tools/demo/mmu/storage/stack/stack.c b/tools/demo/mmu/storage/stack/stack.c
index 08d6df2..4a49f9e 100644
--- a/tools/demo/mmu/storage/stack/stack.c
+++ b/tools/demo/mmu/storage/stack/stack.c
@@ -171,10 +171,28 @@
 /*
  * Near Call
  *
- *   When executing a near call. the processor pushes the value of the EIP
- *   register (which contains the offset the instruction following the 
- *   CALL instruction) on the task (for use later as a return-instruction
- *   pointer).
+ *   When executing a near call, the processor pushes the value of the EIP
+ *   register (which contains the offset of the instruction following the
+ *   the CALL instruction) on stack (for use later as a return-instruction
+ *   pointer). The processor then branches to the address in the current
+ *   code segment specified by the target operand. The target relative
+ *   offset (a signed displacement relative to the current value of the
+ *   instruction pointer in the EIP register, this value points to the 
+ *   instruction following the CALL instruction). The CS register is not
+ *   changed on near calls.
+ *
+ *   For a near call absolute, an absolute offset is specified indirectly
+ *   in a general-purpose register or a memory location (r/m16, r/m32). 
+ *   The operand-size attribute determines the size of the target operand (
+ *   16, 32 or 64 bits). Absolute offsets are loaded directly into the 
+ *   EIP(RIP) register. If the operand size attribute is 16, the upper
+ *   two bytes of the EIP register are cleared, resulting in a maximum
+ *   instruction pointer size of 16 bits. When accessing an absolute offset
+ *   indirectly using the stack pointer [ESP] as the base register, the
+ *   base value used is the value of the ESP before the instruction executes.
+ *   
+ *   A example, the calling procedure is 'debug_near_call()' and called
+ *   procedure is "near_call_procedure()".
  */
 
 /*
@@ -725,6 +743,23 @@ static __unused int debug_near_call(void)
     return 0;
 }
 
+/*
+ * Far Calls in Protected Mode
+ *
+ *   When the processor is operating in protected mode, the CALL instruction
+ *   can be used to perform the following types of the far calls:
+ *
+ *   * Far call to the same privilege level
+ *   * Far call to a different privilege level (inter-privilege level call)
+ *   * Task switch (far call to another task)
+ *
+ *   In protected mode, the processor always uses the segment selector part
+ *   of the far address to access the corresponding descriptor in the GDT
+ *   or LDT. The descriptor type (code segment, call gate, task gate, or
+ *   TSS) and access rights determine the type of call operation to be
+ *   performed.
+ */
+
 #ifdef CONFIG_DEBUG_CALL_INSTR
 static int debug_CALL_RETURN_instr(void)
 {
-- 
1.9.1

