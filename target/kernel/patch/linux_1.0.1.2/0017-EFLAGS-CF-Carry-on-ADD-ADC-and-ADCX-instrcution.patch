From 8780fd58bb154b4fd1ab49699355d61041cb98ea Mon Sep 17 00:00:00 2001
From: BuddyZhang1 <buddy.zhang@aliyun.com>
Date: Tue, 14 Aug 2018 10:42:34 +0800
Subject: [PATCH 17/27] EFLAGS -- CF: Carry on ADD, ADC, and ADCX instrcution

---
 tools/demo/mmu/storage/register/EFLAGS/Kconfig  |  15 ++++
 tools/demo/mmu/storage/register/EFLAGS/eflags.c | 109 ++++++++++++++++++++++++
 2 files changed, 124 insertions(+)

diff --git a/tools/demo/mmu/storage/register/EFLAGS/Kconfig b/tools/demo/mmu/storage/register/EFLAGS/Kconfig
index 77245ba..c4c5e5a 100644
--- a/tools/demo/mmu/storage/register/EFLAGS/Kconfig
+++ b/tools/demo/mmu/storage/register/EFLAGS/Kconfig
@@ -48,6 +48,21 @@ config DEBUG_CF_AAS
 	help
 	  Borrow on unpacked BCD via AAS instruction.
 
+config DEBUG_CF_ADC
+	bool "CF: Addition with carry via ADC instruction"
+	help
+	  Addition with carry via ADC instruction.
+
+config DEBUG_CF_ADCX
+	bool "CF: Addition of two operands with Carry flag"
+	help
+	  Unsigned integer addition of two operands with Carry flag
+
+config DEBUG_CF_ADD
+	bool "CF: Carroy on ADD instruction"
+	help
+	  Debug ADD instruction for carrying on.
+
 endif # DEBUG_EFLAGS_CF
 
 endif
diff --git a/tools/demo/mmu/storage/register/EFLAGS/eflags.c b/tools/demo/mmu/storage/register/EFLAGS/eflags.c
index d34a576..d1d67c6 100644
--- a/tools/demo/mmu/storage/register/EFLAGS/eflags.c
+++ b/tools/demo/mmu/storage/register/EFLAGS/eflags.c
@@ -187,6 +187,8 @@ static __unused int eflags_CF(void)
 {
     unsigned char  __unused CF;
     unsigned short __unused AX;
+    unsigned short __unused BX;
+    unsigned int   __unused EAX;
 
 #ifdef CONFIG_DEBUG_CF_AAA
     /* 
@@ -338,6 +340,113 @@ static __unused int eflags_CF(void)
 
 #endif
 
+#ifdef CONFIG_DEBUG_CF_ADC
+    /*
+     * ADC -- Add with Carry
+     *
+     * Adds the destination operand (first operand), the source operand (
+     * second operand), and the carry (CF) flag and stores the result in the
+     * destination operand. The destination operand can be a register or a
+     * memory location; the source operand can be an immediate, a register,
+     * or a memory location. (However, two memory operand cannot be used in
+     * one instruction.) The state of the CF flag represents a carry from
+     * a previous addition. When an immediate value is used as an operand,
+     * it is sign-extended to the length of the destination operand format.
+     *
+     * The ADC instruction does not distinguish between signed or unsigned
+     * operands. Instead, the processor evaluates the result for both data
+     * types and sets the OF and CF flags to indicate a carry in the signed
+     * unsigned result, respectively. The SF flags indicates the sign of the
+     * signed result.
+     *
+     * DEST <---- DEST + SRC + CF
+     *
+     */
+    __asm__ ("mov $0xFFFF, %%ax\n\r"
+             "add $0x1, %%ax\n\r"
+             "mov $0x0, %%bx\n\r"
+             "adc $0x1, %%bx\n\r"
+             "mov %%bx, %0" : "=m" (BX) :);
+    printk("ADC: BX = BX(0) + 1 + CF = %#x\n", BX);
+#endif
+
+#ifdef CONFIG_DEBUG_CF_ADCX
+    /*
+     * ADCX -- Unsigned integer addition of two operands with Carry flags
+     *
+     * Performs an unsigned addition of the destination operand (first 
+     * operand), the source operand (second operand) and the carry-flag (CF)
+     * and stores the result in the destination operand. The destination 
+     * operand is a general purpose register, whereas the source operand
+     * can be a general-purpose register or memory location. The state of
+     * CF can represent a carry from a previous addition. The instruction
+     * sets the CF flag with the carry generated by the unsigned addition
+     * of the operands.
+     *
+     * The ADCX instruction is executed in the context of multi-precision 
+     * addition, where we add a series of operands with a carry-chain. At
+     * the beginning of a chain of additions, we need to make sure the CF
+     * is in a desired initial state. Often, this inital state need to be
+     * 0, which can be achieved with an instruction to zero the CF.
+     *
+     * CF:DEST[31:0] <---- DEST[31:0] + SRC[31:0] + CF
+     */
+    __asm__ ("movl $0xFFFFFFFF, %%eax\n\r"
+             "adcx $0x1, %%eax\n\r"
+             "jc CF_SET\n\r"
+             "jnc CF_CLEAR\n\r"
+      "CF_SET:\n\r"
+             "mov $1, %%bx\n\r"
+             "jmp out\n\r"
+    "CF_CLEAR:\n\r"
+             "mov $0, %%bx\n\r"
+         "out:\n\r"
+             "mov %%bx, %0\n\r"
+             "movl %%eax, %1"
+             : "=m" (CF), "=m" (EAX) :);
+    if (CF)
+        printk("ADCX: 0xFFFFFFFF + 0x1 + CF = %#x\n", EAX);
+#endif
+
+#ifdef CONFIG_DEBUG_CF_ADD
+    /*
+     * ADD -- Addition with two operands.
+     *
+     * Adds the destination operand (first operand) and the source operand (
+     * second operand) and then stores the result in the destination operand.
+     * The destination operand can be a register or a memory location; the 
+     * source operand can be an immediate, a register, or a memory location.
+     * (However, two memory operands cannot be used in one instruction.) When
+     * an immediate value is used as an operand, it it sign-extended to the
+     * length of the destination operand format.
+     * 
+     * The ADD instruction performs integer addition. It evaluates the result
+     * for both signed and unsigned integer operands and sets the CF and
+     * OF flags to indicate a carry (overflow) in the signed or unsigned 
+     * result, respectively. The SF flag indicates the sign of the signed 
+     * result.
+     *
+     * DEST <---- DEST + SRC
+     *
+     * The OF, SF, ZF, AF, CF, and PF flags are set according to the result.
+     */
+    __asm__ ("mov $0xFFFF, %%ax\n\r"
+             "add $1, %%ax\n\r"
+             "jc CF_SET\n\r"
+             "jnc CF_CLEAR\n\r"
+      "CF_SET:\n\r"
+             "mov $1, %%bx\n\r"
+             "jmp out\n\r"
+    "CF_CLEAR:\n\r"
+             "mov $0, %%bx\n\r"
+         "out:\n\r"
+             "mov %%bx, %0\n\r"
+             "mov %%ax, %1"
+             : "=m" (CF), "=m" (AX) :);
+    if (CF) 
+        printk("ADD: Carry on 0xFFFF + 0x1 = %#x\n", AX);
+#endif
+
     return 0;
 }
 
-- 
1.9.1

