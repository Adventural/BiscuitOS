From dfd69482d541e89ed99cb51d0084d1fc5b35f330 Mon Sep 17 00:00:00 2001
From: BuddyZhang1 <buddy.zhang@aliyun.com>
Date: Fri, 14 Sep 2018 19:23:54 +0800
Subject: [PATCH 47/52] EFLAGS -- ZF: ARPL, BSF, and BSR instruction effect ZF
 set and clear

---
 tools/demo/mmu/storage/register/EFLAGS/eflags.c | 309 +++++++++++++++++++++++-
 1 file changed, 308 insertions(+), 1 deletion(-)

diff --git a/tools/demo/mmu/storage/register/EFLAGS/eflags.c b/tools/demo/mmu/storage/register/EFLAGS/eflags.c
index 9fce900..765e63e 100644
--- a/tools/demo/mmu/storage/register/EFLAGS/eflags.c
+++ b/tools/demo/mmu/storage/register/EFLAGS/eflags.c
@@ -2912,7 +2912,7 @@ static __unused int eflags_PF(void)
     if (PF)
         printk("SCASB: even number ->");
     else
-        printk("SCASW: odd number ->");
+        printk("SCASB: odd number ->");
 
     printk("\"%s\" Scan \"%c\" in %d\n", 
            (char *)(unsigned long)ECX, AL, CX - AX - 1);
@@ -4160,6 +4160,313 @@ static __unused int eflags_ZF(void)
            (char *)(unsigned long)ECX, AL, CX - AX - 1);
 #endif
 
+#ifdef CONFIG_DEBUG_ZF_SCASW
+    /*
+     * SCASW -- Scan String in Word
+     *
+     * The no-operands form of the instruction uses a short form of SCAS. 
+     * Again, ES:(E)DI is assumed to be the memory operand and AL, AX, or EAX
+     * is assumed to be the register operand. The size of operands is 
+     * selected by the mnemonic: SCASW (word comparision).
+     * 
+     * After the comparison, the (EDI) register is increamented or decremented
+     * automatically according to the setting of the DF flag in the EFLAGS
+     * register. If the DF flag is 0, the (E)DI register is increamented; if
+     * the DF flag is 1, the (E)DI register is decremented. The register is
+     * increamented or decremented by 1 for byte operations.
+     *
+     * SCASW can be preceded by the REP prefix for block comparisions of ECX
+     * word. Often, however, these instructions will be used in a LOOP 
+     * construct that takes some action based on the setting of status flags.
+     */
+    ECX = (unsigned int)(unsigned long)&"Hello World"[0];
+    AX  = (unsigned short)(unsigned long)(('o' << 8) | 'W');
+    CX  = 15;
+    __asm__ ("movl %2, %%edi\n\r"
+             "mov %3, %%ax\n\r"
+             "mov %4, %%cx\n\r"
+             "cld\n\r"
+             "repne scasw\n\r"
+             "jz ZF_SK\n\r"
+             "jnz ZF_CK\n\r"
+       "ZF_SK:\n\r"
+             "mov $1, %%dx\n\r"
+             "jmp outK\n\r"
+       "ZF_CK:\n\r"
+             "mov $0, %%dx\n\r"
+        "outK:\n\r"
+             "mov %%dx, %0\n\r"
+             "mov %%cx, %1"
+             : "=m" (ZF), "=m" (BX)
+             : "m" (ECX), "m" (AX), "m" (CX));
+    if (ZF)
+        printk("SCASW: Zero -> ");
+    else
+        printk("SCASW: Non-Zero -> ");
+    printk("\"%s\" scan \"%c%c\" in %d word\n", (char *)(unsigned long)ECX,
+                 (unsigned char)(unsigned long)((AX >> 0) & 0xFF), 
+                 (unsigned char)(unsigned long)((AX >> 8) & 0xFF), 
+                 CX - BX - 1);
+#endif
+
+#ifdef CONFIG_DEBUG_ZF_SUB
+    /*
+     * SUB -- Subtract
+     *
+     * SUB AL, imm8
+     * SUB AX, imm16
+     * SUB EAX, imm32
+     *
+     * Subracts the second operand (source operand) from the first operand (
+     * destination operand) and stores the result in the destination operand.
+     * The destination operand can be a register or a memory location; the 
+     * source operand can be an immediate, register, or memory location. (
+     * However, two memory operands cannot be used in one instruction.) When
+     * an immediate value is used as an operand, it is sign-extended to the
+     * length of the destination operand format.
+     *
+     * The SUB instruction performs integer subtraction. It evaluates the 
+     * result for both signed and unsigned integer operands and sets the
+     * OF and CF flags to indicate an overflow in the signed or unsigned
+     * result, respectively. The SF flag indicates the sign of the signed
+     * result.
+     *
+     * DEST <---- (DEST - SRC)
+     *
+     * The OF, SF, ZF, AF, PF, and CF flags are set according to the result.
+     */
+    CX = 0x1;
+    DX = 0x1;
+    __asm__ ("mov %2, %%al\n\r"
+             "mov %3, %%bl\n\r"
+             "sub %%bl, %%al\n\r"
+             "jz ZF_SL\n\r"
+             "jnz ZF_CL\n\r"
+       "ZF_SL:\n\r"
+             "mov $1, %%dx\n\r"
+             "jmp outL\n\r"
+       "ZF_CL:\n\r"
+             "mov $0, %%dx\n\r"
+        "outL:\n\r"
+             "mov %%dx, %0\n\r"
+             "mov %%ax, %1"
+             : "=m" (ZF), "=m" (AX)
+             : "m" (CX), "m" (DX));
+    if (ZF)
+        printk("SUB: Zero -> %#x - %#x = %#x\n", CX, DX, AX & 0xFF);
+    else
+        printk("SUB: Non-Zero -> %#x - %#x = %#x\n", CX, DX, AX & 0xFF);
+#endif
+
+#ifdef CONFIG_DEBUG_ZF_TEST
+    /*
+     * TEST -- Logical Compare
+     *
+     * Computes the bit-wise logical AND of first operand (source 1 operand)
+     * and second operand (source 2 operand) and sets the SF, ZF, and PF
+     * status flags according to the result. The result is then discarded.
+     *
+     */
+    CX = 0xAA;
+    DX = 0x55;
+    __asm__ ("mov %2, %%al\n\r"
+             "mov %3, %%bl\n\r"
+             "test %%bl, %%al\n\r"
+             "jz ZF_SM\n\r"
+             "jnz ZF_CM\n\r"
+       "ZF_SM:\n\r"
+             "mov $1, %%dx\n\r"
+             "jmp outM\n\r"
+       "ZF_CM:\n\r"
+             "mov $0, %%dx\n\r"
+        "outM:\n\r"
+             "mov %%dx, %0\n\r"
+             "mov %%ax, %1"
+             : "=m" (ZF), "=m" (AX)
+             : "m" (CX), "m" (DX));
+    if (ZF)
+        printk("TEST: Zero -> %#x & %#x = %#x\n", CX, DX, (CX & DX) & 0xFF);
+    else
+        printk("TEST: Non-Zero -> %#x & %#x = %#x\n", CX, DX, 
+                    (CX & DX) & 0xFF);
+#endif
+
+#ifdef CONFIG_DEBUG_ZF_ARPL
+    /*
+     * ARPL -- Adjust RPL field of segment selector
+     *
+     * Compares the PRL fields of two segment selectors. The first operand (
+     * the destination operand) contains one segment selector and the second
+     * operand (source operand) contains the other. (The RPL field is located
+     * in bits 0 and 1 of each operand.) If the RPL field of the destination
+     * operand is less then the PRL field of the source operand, the ZF flag
+     * is set and the RPL field of the destination operand is increased to 
+     * match that of the source operand. Otherwise, the ZF flag is cleared and
+     * no change  is made to the destination operand. (The destination operand
+     * can be a word register or memory location; then source operand must be
+     * a word register.)
+     *
+     * The ARPL instruction is provided for use by operating-system procedures
+     * (however, it can also be used by applications). It is generally used
+     * to adjust the PRL of a segment selector that has been passed to the 
+     * operating system by an application program to match the privilege level
+     * of the application program. Here the segment selector passed to the 
+     * operating system is placed in the destination operand and segment 
+     * selector for the application program's code segment is placed in the 
+     * source operand. (The RPL field in the source operand represents the 
+     * privilege level of the application program.) Execution of the ARPL
+     * instruction then ensures that the PRL of the segment selector received
+     * by the operating system is no lower (does not have a higher privilege)
+     * than the privilege level of the application program (the segment 
+     * selector for the application program's code segment can be read from
+     * the stack following a procedure call).
+     *
+     * IF 64-BIT MODE
+     *   THEN
+     *     See MOVSXD
+     *   ELSE
+     *     IF DEST [RPL] < SRC [RPL]
+     *       THEN
+     *         ZF <---- 1;
+     *         DEST [RPL] <---- SRC[RPL];
+     *       ELSE
+     *         ZF <---- 0;
+     *     FI
+     * FI
+     *
+     * Flags Affected
+     * 
+     * The ZF flag is set to 1 if the RPL field of the destination operand
+     * is less than of the source operand; otherwise, it is set to 0.
+     */
+    CX = 0x01;
+    __asm__ ("mov %3, %%cx\n\r"
+             "mov %%es, %%ax\n\r"
+             "mov %%ax, %0\n\r"
+             "arpl %%cx, %%ax\n\r"
+             "jz ZF_SN\n\r"
+             "jnz ZF_CN\n\r"
+       "ZF_SN:\n\r"
+             "mov $1, %%dx\n\r"
+             "jmp outN\n\r"
+       "ZF_CN:\n\r"
+             "mov $0, %%dx\n\r"
+        "outN:\n\r"
+             "mov %%dx, %1\n\r"
+             "mov %%ax, %2"
+             : "=m" (AX), "=m" (ZF), "=m" (BX)
+             : "m" (CX));
+    if (ZF) {
+        printk("ARPL: Zero -> ES segment ARPL %#x less %#x\n", AX & 0x3, CX);
+        printk("Change ES Segment ARPL %#x to %#x\n", AX & 0x3, BX & 0x3);
+    } else {
+        printk("ARPL: Non-Zero -> ES segment ARPL %#x same as %#x\n", 
+                                         AX & 0x3, CX);
+    }
+#endif
+
+#ifdef CONFIG_DEBUG_ZF_BSF
+    /*
+     * BSF -- Bit scan forward
+     *
+     * Searches the source operand (second operand) for the least significat 
+     * set bit (1 bit). If a least significant 1 bit is found, its bit index
+     * is stored in the destination operand (first operand). The source 
+     * operand can be a register or a memory location; the destination operand
+     * is a register. The bit index is an unsinged offset from bit 0 of the
+     * source operand. If the content of the source operand is 0, the content
+     * of the destination operand is undefined.
+     *
+     * IF SRC = 0
+     *   THEN
+     *     ZF     <---- 1;
+     *     DEST is undefined;
+     *   ELSE
+     *     ZF     <---- 0;
+     *     temp   <---- 0;
+     *     WHILE Bit(SRC, temp) = 0;
+     *     DO
+     *       temp <---- temp + 1;
+     *     OD;
+     *     DEST   <---- temp;
+     * FI
+     *
+     * The ZF flag is set to 1 if all the source operand is 0; otherwise, the
+     * ZF flag is cleared. The CF, OF, SF, AF, and PF, flags are undefined.
+     */
+    CX = 0x700;
+    __asm__ ("mov %2, %%ax\n\r"
+             "bsf %%ax, %%bx\n\r"
+             "jz ZF_SO\n\r"
+             "jnz ZF_CO\n\r"
+       "ZF_SO:\n\r"
+             "mov $1, %%dx\n\r"
+             "jmp outO\n\r"
+       "ZF_CO:\n\r"
+             "mov $0, %%dx\n\r"
+        "outO:\n\r"
+             "mov %%dx, %0\n\r"
+             "mov %%bx, %1"
+             : "=m" (ZF), "=m" (AX)
+             : "m" (CX));
+    if (ZF)
+        printk("BSF: Zero -> %#x can't find 1\n", CX);
+    else
+        printk("BSF: Non-Zero -> %#x find first least bit 1 on bit %#x\n", 
+                                                   CX, AX);
+#endif
+
+#ifdef CONFIG_DEBUG_ZF_BSR
+    /*
+     * BSR -- Bit Scan Reverse
+     *
+     * Searches the source operand (second operand) for the most significant 
+     * set bit (1 bit). If a most significant 1 bit is found, its bit index
+     * is stored in the destination operand (first operand). The source operand
+     * can be a register or a memory location; the destination operand is a
+     * register. The bit index is an unsigned offset from bit 0 of the source
+     * operand. If the content source operand is 0, the content of the 
+     * destination operand is undefined.
+     *
+     * IF SRC = 0
+     *   THEN
+     *     ZF     <---- 1;
+     *     DEST is undefined
+     *   ELSE
+     *     zF     <---- 0;
+     *     temp   <---- OperandSize - 1;
+     *     WHILE BIT(SRC, temp) = 0
+     *     DO
+     *       temp <---- temp - 1;
+     *     OD;
+     *     DEST   <---- temp;
+     * FI
+     *
+     * The ZF flag is set to 1 if all the source operand is 0; otherwise. the
+     * ZF flag is cleared.
+     */
+    CX = 0x300;
+    __asm__ ("mov %2, %%ax\n\r"
+             "bsr %%ax, %%bx\n\r"
+             "jz ZF_SP\n\r"
+             "jnz ZF_CP\n\r"
+       "ZF_SP:\n\r"
+             "mov $1, %%dx\n\r"
+             "jmp outP\n\r"
+       "ZF_CP:\n\r"
+             "mov $0, %%dx\n\r"
+        "outP:\n\r"
+             "mov %%dx, %0\n\r"
+             "mov %%bx, %1"
+             : "=m" (ZF), "=m" (AX)
+             : "m" (CX));
+    if (ZF)
+        printk("BSR: Zero -> %#x can't find 1\n", CX);
+    else
+        printk("BSR: Non-Zero -> %#x find first most bit 1 on bit %#x\n",
+                                                  CX, AX);
+#endif
+
     return 0;
 }
 
-- 
2.7.4

