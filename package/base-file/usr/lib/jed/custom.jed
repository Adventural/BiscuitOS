Customizing Jed:

   Jed has an embedded language interpreter know as S-Lang.  This makes JED
customizable.  See some of the *.sl files for examples of how this works.
For details on the S-Lang programming language, read the file slang.txt.

   Most people will simply want to rebind their keys to a more familiar set.
For a description of how to do this, read the file keys.doc and see the file
emacs.sl for an explicit demonstration of how to do this.

   The purpose of this document is to provide a technical description of the
JED enhancements to the S-Lang language.  See slang.txt for details
intrinsic to the language.

The functions will be described as in the following example:

ffind (string s): integer

  search forward for string s.  Returns 1 if found, 0 if not.  Search
  confined to current line.  
  See: bfind, fsearch, bsearch

This means that the function ffind removes a string from the top of the
stack, performs the prescribed search and returns an integer to the stack.
Example usage: "hello" ffind 

call (string s)			

   call jed function s.  s is a function which is may be bound to a key

skip_chars(string) 

   skip past all characters in string s.  
   whitespace is a range of ascii characters as in "ae" which means skip
   past characters a,b,c,d,e stopping at first one not in the set
   skipped. If s begins or ends in a space, skip whitespace as well.
   See: skip_white
   
mail

   Unix only.  Edit a mail message.  Use `send' to send it.  See send.
   

send

   Unix only.  Sends a previously formatted mail message.  See mail.
   
flush

   Flush message buffer to screen immediately.  Do not wait for top level. 
   See: message, update

setmode(string s)

   Set mode to s.  If s is "wrap", set mode to text-mode.  If mode is "cmode"
   set mode for editing C code.  If mode is "nomode" remove any current mode.
   Any other value of mode is considered to be a user defined mode and the
   mode string on the status line assumes its value.
   
skip_white

   Skip past whitespace.  This does not cross lines.  See: skip_chars

looking_at (string s): integer

   Returns 1 if Point is positioned on string s, otherwise returns 0.  
   See: ffind
   
showkey

   reads next key sequence and prints its binding in the minibuffer
   
evalfile (string file): integer

   loads file as S-Lang code and evaluates it.  Returns 1 if the file was
   found or 0 if not.  See: evalbuffer
   
evalbuffer (string name)

   evaluates a buffer as S-Lang code.  See: evalfile
   
   
erase_buffer

   erases all text from the current buffer.  
   See: delbuf
   
   
whitespace (integer n)

   inserts whitespace of length n using tabs and spaces.  If the global
   variable  TAB is 0, only spaces are used.
   
bol

   Move editing Point to the beginning of current line.  See: bolp, eol
   
eol

   Move editing Point to the end of current line.  See: eolp, eob, bob
   
   
bob
   Move Point to beginning of buffer.  See: bol, eob, bobp
   
eob

   Move Point to end of buffer.  See: bob, eobp, eol
   
bobp :integer

   Returns TRUE if Point is at the beginning of the buffer.
   See: bob, eob, bol
   
bolp

   Returns TRUE if Point is at the beginning of a line.
   See: bobp, bob, eobp
   

eobp :integer

   Returns TRUE if Point is at the end of the buffer.
   See: eob, bobp, eolp
   
eolp

   Returns TRUE if Point is at the end of a line.
   See: bobp, bob, eobp
   

insert (string s)

   insert string s at Point in buffer.  To insert a newline character in
   buffer do ` "\n" insert '.  See: whitespace, del
   
del

   delete character at current Point.  
   See: insert, trim
   
up (integer n) : integer

   Move editing Point up n lines returning number actually moved.
   See: down, left, right

down (integer n) : integer

   Move editing Point down n lines returning number actually moved.
   See: up, left, right

left (integer n) : integer

   Move editing Point left n characters returning number actually moved.  If
   beginning of a line is reached, Point will move to end of previous line.
   See:  right, up, down

right (integer n) : integer

   Move editing Point right n characters returning number actually moved.  If
   end of a line is reached, Point will move to beginning of next line.
   See:  left, up, down

pageup

   Scroll screen up one screenful.
   See: up, pagedown
   
pagedown   

   Scroll screen down one screenful.
   See: down, pageup
   
push_spot

   Save the current buffer position for future reference.  This is the
   proper call to make when it is desired to remember a buffer postion.
   See: pop_spot, push_mark

pop_spot

   Returns to previously pushed ``spot''. 
   See: push_spot, pop_mark.
   
push_mark

   Push the current editing point as a mark.  Many builtin commands pop the
   mark and use it to mark the start of a region.
   See push_spot, pop_mark
   
pop_mark

   Pop a previously pushed mark and move Point to it.  
   See: pop_spot, push_mark.

goto_line (integer n)

   Move point to line n of current buffer.  
   See: goto_column, what_line
   
goto_column (integer)

   Move point to column n of buffer taking into account current tab setting.  
   If column is beyond end of current line, whitespace will be inserted.
   See: goto_line, what_column
   
whatline : integer

   Returns current line number of Point in buffer.
   See: what_column, goto_line
   
what_column : integer

   Returns current column of Point in buffer.  This takes into account the
   current tab setting.
   See: whatline, goto_column
   
trim

   deletes all whitespace around current point.  Whitespace is considered to
   consist of space and tab characters.
   See: del, whitespace
   
onewindow

   Delete all other windows leaving only current one with the exception of
   the MiniBuffer window.
   See: splitwindow, otherwindow, nwindows
   
splitwindow

   Split current window in half.
   See: enlargewin, otherwindow, pop2buf
   
enlargewin
   
   Increase the size of current window by one line.  Others are reduced
   accordingly. 
   See: onewindow, splitwindow
   
pop2buf (string name)

   Switch to buffer name in another window creating on if necessary.
   See: sw2buf, setbuf, splitwindow, delbuf, bufferp
   
sw2buf (string name) 

   Make buffer name the new buffer for editing in the current window
   replacing one in window.
   See: setbuf, pop2buf, delbuf
   
setbuf (string name)

   Set buffer name as buffer for editing.  This is a temporary change since
   old buffer is automaticall switched to at top level.
   See: sw2buf, pop2buf
   
bufferp (string name) : integer

   Returns true if buffer name exists.
   See: whatbuf, sw2buf, setbuf, delbuf
   
   
whatbuf : string

   Returns the name of current buffer as a string.
   See: bufferp
   
insbuf (string name)

   Insert contents of buffer name into current buffer at Point.  name must
   be different from current buffer.
   See: whatbuf
   
delbuf (string name)

   Delete buffer name and all its contents.
   See: erase_buffer
   
write_buffer (string file) : integer

   Write current buffer to file returning TRUE if successful.
   See: find_file, insbuf
   
find_file (string file) : integer

   Read file into new buffer returning TRUE if successful.
   See: insbuf, write_buffer


ffind (string s): integer

  search forward for string s.  Returns 1 if found, 0 if not.  Search
  confined to current line.  
  See bfind, fsearch, bsearch

bfind (string s): integer

  search backward for string s.  Returns 1 if found, 0 if not.  Search
  confined to current line.  
  See ffind, fsearch, bsearch

fsearch (string s): integer

  search forward for string s crossing lines if necessary.  Returns 1 if
  found, 0 if not. 
  See ffind, bsearch

   
bsearch (string s): integer

  search backward for string s crossing lines if necessary.  Returns 1 if
  found, 0 if not. 
  See bfind, fsearch

narrow

  Restrict editing commands to region of lines defined by mark and Point.
  If the buffer is already narrowed, it is first widened.
  See: widen, push_mark
  
widen

  Remove restriction replaced on buffer by narrow.
  See: narrow.

indent_line

  indent current line according to current mode.  If the mode is ``cmode'',
  indents line as C code.  Otherwise, it is treated like text.
  See: setmode
  
time : string

  Returns cureent time and date as a string.
  
message (string s)

  Display message in minibuffer.  This is displayed only when screen is
  updated.  To flush it to screen immediately, follow with a call to `flush'.
  See: flush, update
  
update

  Update screen now.
  See: flush, message
  
setkey (string f, string key)

  Sets key sequence key to invoke function f in global map.  In fact, this
  has the same effect as `f key "global" definekey'.
  
  See: definekey, unsetkey
  
unsetkey (string key)

  Removes the defintion of key from global keymap.
  See: undefinekey, setkey
  
definekey (string f, string key, string keymap)

  Sets key sequence key in keymap keymap to invoke function f.
  See: setkey, undefinekey, make_keymap, use_keymap
  
make_keymap (string map)

  Creates a new keymap with name map.  The newly created keymap is an exact
  copy of the global map "global".
  See: use_keymap, definekey, undefinekey
  
use_keymap (string name)

  Associate keymap name with current buffer.  By default the global keymap
  "global" is used.  Use this function to override the default behavior.
  See: make_keymap.
  
exit_jed

  Exit the JED editor asking user to save any buffers which have benn
  modified.
  
copy_rect

  saves a copy of rectangle defined by Mark and Point into an internal
  buffer to be pasted at a later time using `insert_rect'
  See: kill_rect, insert_rect
  
insert_rect

  Pastes a previously saved or killed rectangle at current Point.
  See: copy_rect, kill_rect, open_rect
  
open_rect

  Opens a rectangle defined by Point and Mark displacing text to the right.
  See: copy_rect, kill_rect, insert_rect
  
kill_rect

  Cuts rectangle defined by Point and Mark and puts them in an internal
  buffer.  The killed rectangle may be pasted back with the `insert_rect'
  function.
  See: insert_rect, copy_rect
  

what_char : integer
   
  returns the ascii value of character at Point. 
  See: string, char, isdigit
  
del_region

   deletes the region between Point and Mark in the current buffer.  The
   region is NOT put in the pastebuffer-- It is gone.
   See: copy_region, set_mark
   
   
copy_region (string name)

   Copies region defined by Point and Mark to buffer name.
   See: del_region, set_mark
   
User Variables:

   User Variables are set like any other variable.  They are:
   
       TAB:   The default is 8.  If this is set to 0 then tabs are 
              not used.  
	
       WRAP: Wrap column.  This is used by the text formatting commands to
             determine where a paragraph gets wrapped.  The default is 78.
	     
       C_INDENT: Amount if space to indent past an opening brace.  The
             default is 3.
	     
       C_BRACE:  Amount of space a brace is indented.  Default is 2.
       
       LAST_CHAR:  Last character entered in from the keyboard.
       
       CASE_SEARCH:  if TRUE, searches respect case.  Default: FALSE (0)
       
       MAX_HITS: an integer which specifies the maximum number of times
                 changes to the buffer before an autosave.
       examples:   
           4 =TAB      ;; 4 column tabs
	   0 =C_BRACE  ;; do not indent braces
	   72 =WRAP    ;; set wrap column to 72

